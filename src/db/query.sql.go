// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAttendance = `-- name: AddAttendance :exec
INSERT INTO yoga.attendance (user_id, lesson_id, date) VALUES ($1, $2, $3)
`

type AddAttendanceParams struct {
	UserID   int64
	LessonID int
	Date     time.Time
}

func (q *Queries) AddAttendance(ctx context.Context, arg AddAttendanceParams) error {
	_, err := q.db.Exec(ctx, addAttendance, arg.UserID, arg.LessonID, arg.Date)
	return err
}

const addDaysToMem = `-- name: AddDaysToMem :exec
UPDATE yoga.membership SET ends = ends + $1 * INTERVAL '1 days' WHERE user_id=$2
`

type AddDaysToMemParams struct {
	Column1 interface{}
	UserID  int64
}

func (q *Queries) AddDaysToMem(ctx context.Context, arg AddDaysToMemParams) error {
	_, err := q.db.Exec(ctx, addDaysToMem, arg.Column1, arg.UserID)
	return err
}

const addLesson = `-- name: AddLesson :one
INSERT INTO yoga.lesson (date, time, description, max) 
VALUES ($1, $2, $3, $4) RETURNING id
`

type AddLessonParams struct {
	Date        time.Time
	Time        time.Time
	Description string
	Max         int
}

func (q *Queries) AddLesson(ctx context.Context, arg AddLessonParams) (int, error) {
	row := q.db.QueryRow(ctx, addLesson,
		arg.Date,
		arg.Time,
		arg.Description,
		arg.Max,
	)
	var id int
	err := row.Scan(&id)
	return id, err
}

const addRegisterdUsersRow = `-- name: AddRegisterdUsersRow :exec
INSERT INTO yoga.registered_users (lesson_id, registered) VALUES ($1, $2)
`

type AddRegisterdUsersRowParams struct {
	LessonID   int
	Registered []int64
}

func (q *Queries) AddRegisterdUsersRow(ctx context.Context, arg AddRegisterdUsersRowParams) error {
	_, err := q.db.Exec(ctx, addRegisterdUsersRow, arg.LessonID, arg.Registered)
	return err
}

const blockUsers = `-- name: BlockUsers :exec
UPDATE yoga.user SET is_blocked = true WHERE id = ANY($1::bigint[])
`

func (q *Queries) BlockUsers(ctx context.Context, ids []int64) error {
	_, err := q.db.Exec(ctx, blockUsers, ids)
	return err
}

const checkIfUserHasCourseAccess = `-- name: CheckIfUserHasCourseAccess :many
SELECT user_id FROM yoga.subscription WHERE user_id=$1 AND ends >= NOW()
`

func (q *Queries) CheckIfUserHasCourseAccess(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, checkIfUserHasCourseAccess, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const decLessonsAvaliable = `-- name: DecLessonsAvaliable :exec
UPDATE yoga.membership SET lessons_avaliable = lessons_avaliable - 1 WHERE user_id=$1
`

func (q *Queries) DecLessonsAvaliable(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, decLessonsAvaliable, userID)
	return err
}

const findUsersByName = `-- name: FindUsersByName :many
SELECT id, username, name, emoji, is_blocked FROM yoga.user WHERE name ILIKE '%' || $1::text || '%' OR username ILIKE '%' || $1::text || '%'
`

func (q *Queries) FindUsersByName(ctx context.Context, name string) ([]YogaUser, error) {
	rows, err := q.db.Query(ctx, findUsersByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []YogaUser
	for rows.Next() {
		var i YogaUser
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Emoji,
			&i.IsBlocked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersWithMemLatest = `-- name: GetAllUsersWithMemLatest :many
SELECT u.id, username, name, emoji, starts, ends, type, lessons_avaliable
FROM yoga.user u INNER JOIN yoga.membership m ON u.id = m.user_id 
WHERE m.ends >= NOW() - INTERVAL '2 months' AND is_blocked = false
`

type GetAllUsersWithMemLatestRow struct {
	ID               int64
	Username         pgtype.Text
	Name             string
	Emoji            string
	Starts           time.Time
	Ends             time.Time
	Type             int
	LessonsAvaliable int
}

func (q *Queries) GetAllUsersWithMemLatest(ctx context.Context) ([]GetAllUsersWithMemLatestRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersWithMemLatest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithMemLatestRow
	for rows.Next() {
		var i GetAllUsersWithMemLatestRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Emoji,
			&i.Starts,
			&i.Ends,
			&i.Type,
			&i.LessonsAvaliable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableLessons = `-- name: GetAvailableLessons :many
SELECT id, date, time, description, max, poll_id FROM yoga.lesson WHERE (date >= (now())::date)
`

func (q *Queries) GetAvailableLessons(ctx context.Context) ([]YogaLesson, error) {
	rows, err := q.db.Query(ctx, getAvailableLessons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []YogaLesson
	for rows.Next() {
		var i YogaLesson
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Time,
			&i.Description,
			&i.Max,
			&i.PollID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstLessonAttendanceId = `-- name: GetFirstLessonAttendanceId :one
SELECT id FROM yoga.attendance WHERE lesson_id=$1 limit 1
`

func (q *Queries) GetFirstLessonAttendanceId(ctx context.Context, lessonID int) (int, error) {
	row := q.db.QueryRow(ctx, getFirstLessonAttendanceId, lessonID)
	var id int
	err := row.Scan(&id)
	return id, err
}

const getLessonWithUsers = `-- name: GetLessonWithUsers :many
SELECT
  l.id as lesson_id,
  date,
  time,
  max,
  description,
  u.id as user_id,
  u.name as name,
  u.username as username,
  u.emoji as emoji
FROM yoga.lesson l LEFT JOIN yoga.registered_users r ON l.id = r.lesson_id
LEFT JOIN yoga.user u ON u.id = ANY(r.registered) WHERE l.id=$1
`

type GetLessonWithUsersRow struct {
	LessonID    int
	Date        time.Time
	Time        time.Time
	Max         int
	Description string
	UserID      pgtype.Int8
	Name        pgtype.Text
	Username    pgtype.Text
	Emoji       pgtype.Text
}

func (q *Queries) GetLessonWithUsers(ctx context.Context, id int) ([]GetLessonWithUsersRow, error) {
	rows, err := q.db.Query(ctx, getLessonWithUsers, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLessonWithUsersRow
	for rows.Next() {
		var i GetLessonWithUsersRow
		if err := rows.Scan(
			&i.LessonID,
			&i.Date,
			&i.Time,
			&i.Max,
			&i.Description,
			&i.UserID,
			&i.Name,
			&i.Username,
			&i.Emoji,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLessonsByDate = `-- name: GetLessonsByDate :many
SELECT id, date, time, description, max, poll_id FROM yoga.lesson WHERE date=$1
`

func (q *Queries) GetLessonsByDate(ctx context.Context, date time.Time) ([]YogaLesson, error) {
	rows, err := q.db.Query(ctx, getLessonsByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []YogaLesson
	for rows.Next() {
		var i YogaLesson
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Time,
			&i.Description,
			&i.Max,
			&i.PollID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembership = `-- name: GetMembership :one
SELECT user_id, starts, ends, type, lessons_avaliable FROM yoga.membership WHERE user_id=$1
`

func (q *Queries) GetMembership(ctx context.Context, userID int64) (YogaMembership, error) {
	row := q.db.QueryRow(ctx, getMembership, userID)
	var i YogaMembership
	err := row.Scan(
		&i.UserID,
		&i.Starts,
		&i.Ends,
		&i.Type,
		&i.LessonsAvaliable,
	)
	return i, err
}

const getRegisteredOnLesson = `-- name: GetRegisteredOnLesson :one
SELECT registered, lesson_id, date
FROM yoga.registered_users INNER JOIN yoga.lesson on id=lesson_id 
WHERE lesson_id=$1
`

type GetRegisteredOnLessonRow struct {
	Registered []int64
	LessonID   int
	Date       time.Time
}

func (q *Queries) GetRegisteredOnLesson(ctx context.Context, lessonID int) (GetRegisteredOnLessonRow, error) {
	row := q.db.QueryRow(ctx, getRegisteredOnLesson, lessonID)
	var i GetRegisteredOnLessonRow
	err := row.Scan(&i.Registered, &i.LessonID, &i.Date)
	return i, err
}

const getRegisteredUsers = `-- name: GetRegisteredUsers :many
SELECT lesson_id, registered FROM yoga.registered_users WHERE lesson_id=$1
`

func (q *Queries) GetRegisteredUsers(ctx context.Context, lessonID int) ([]YogaRegisteredUser, error) {
	rows, err := q.db.Query(ctx, getRegisteredUsers, lessonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []YogaRegisteredUser
	for rows.Next() {
		var i YogaRegisteredUser
		if err := rows.Scan(&i.LessonID, &i.Registered); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithMembership = `-- name: GetUserWithMembership :one
SELECT u.id, username, name, emoji, starts, ends, type, lessons_avaliable
FROM yoga.user u LEFT JOIN yoga.membership m ON u.id = m.user_id WHERE u.id=$1
`

type GetUserWithMembershipRow struct {
	ID               int64
	Username         pgtype.Text
	Name             string
	Emoji            string
	Starts           pgtype.Date
	Ends             pgtype.Date
	Type             pgtype.Int4
	LessonsAvaliable pgtype.Int4
}

func (q *Queries) GetUserWithMembership(ctx context.Context, id int64) (GetUserWithMembershipRow, error) {
	row := q.db.QueryRow(ctx, getUserWithMembership, id)
	var i GetUserWithMembershipRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Name,
		&i.Emoji,
		&i.Starts,
		&i.Ends,
		&i.Type,
		&i.LessonsAvaliable,
	)
	return i, err
}

const getUsersAttandance = `-- name: GetUsersAttandance :many
SELECT u.id, username, name, emoji, COUNT(user_id) AS count FROM yoga.attendance 
JOIN yoga.user u ON u.id = user_id WHERE date>= $1 and date <= $2 
GROUP BY u.id, username, name, emoji ORDER BY count DESC
`

type GetUsersAttandanceParams struct {
	FromDate time.Time
	ToDate   time.Time
}

type GetUsersAttandanceRow struct {
	ID       int64
	Username pgtype.Text
	Name     string
	Emoji    string
	Count    int64
}

func (q *Queries) GetUsersAttandance(ctx context.Context, arg GetUsersAttandanceParams) ([]GetUsersAttandanceRow, error) {
	rows, err := q.db.Query(ctx, getUsersAttandance, arg.FromDate, arg.ToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersAttandanceRow
	for rows.Next() {
		var i GetUsersAttandanceRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Name,
			&i.Emoji,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersIDs = `-- name: GetUsersIDs :many
SELECT id FROM yoga.user WHERE is_blocked = false
`

func (q *Queries) GetUsersIDs(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUsersIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersIDsWithValidMem = `-- name: GetUsersIDsWithValidMem :many
SELECT user_id FROM yoga.membership m WHERE m.ends > NOW()
`

func (q *Queries) GetUsersIDsWithValidMem(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getUsersIDsWithValidMem)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var user_id int64
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerUser = `-- name: RegisterUser :exec
UPDATE yoga.registered_users
SET registered = array_append(registered, $1)
WHERE lesson_id=$2 AND NOT ($1=ANY(registered))
`

type RegisterUserParams struct {
	ArrayAppend interface{}
	LessonID    int
}

func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) error {
	_, err := q.db.Exec(ctx, registerUser, arg.ArrayAppend, arg.LessonID)
	return err
}

const unregisterUser = `-- name: UnregisterUser :exec
UPDATE yoga.registered_users
SET registered = array_remove(registered, $1)
WHERE lesson_id=$2
`

type UnregisterUserParams struct {
	ArrayRemove interface{}
	LessonID    int
}

func (q *Queries) UnregisterUser(ctx context.Context, arg UnregisterUserParams) error {
	_, err := q.db.Exec(ctx, unregisterUser, arg.ArrayRemove, arg.LessonID)
	return err
}

const updateEmoji = `-- name: UpdateEmoji :exec
UPDATE yoga.user SET emoji=$1 WHERE id=$2
`

type UpdateEmojiParams struct {
	Emoji string
	ID    int64
}

func (q *Queries) UpdateEmoji(ctx context.Context, arg UpdateEmojiParams) error {
	_, err := q.db.Exec(ctx, updateEmoji, arg.Emoji, arg.ID)
	return err
}

const updateLessonDate = `-- name: UpdateLessonDate :exec
UPDATE yoga.lesson SET date=$1 WHERE id=$2
`

type UpdateLessonDateParams struct {
	Date time.Time
	ID   int
}

func (q *Queries) UpdateLessonDate(ctx context.Context, arg UpdateLessonDateParams) error {
	_, err := q.db.Exec(ctx, updateLessonDate, arg.Date, arg.ID)
	return err
}

const updateLessonDesc = `-- name: UpdateLessonDesc :exec
UPDATE yoga.lesson SET description=$1 WHERE id=$2
`

type UpdateLessonDescParams struct {
	Description string
	ID          int
}

func (q *Queries) UpdateLessonDesc(ctx context.Context, arg UpdateLessonDescParams) error {
	_, err := q.db.Exec(ctx, updateLessonDesc, arg.Description, arg.ID)
	return err
}

const updateLessonMax = `-- name: UpdateLessonMax :exec
UPDATE yoga.lesson SET max=$1 WHERE id=$2
`

type UpdateLessonMaxParams struct {
	Max int
	ID  int
}

func (q *Queries) UpdateLessonMax(ctx context.Context, arg UpdateLessonMaxParams) error {
	_, err := q.db.Exec(ctx, updateLessonMax, arg.Max, arg.ID)
	return err
}

const updateLessonTime = `-- name: UpdateLessonTime :exec
UPDATE yoga.lesson SET time=$1 WHERE id=$2
`

type UpdateLessonTimeParams struct {
	Time time.Time
	ID   int
}

func (q *Queries) UpdateLessonTime(ctx context.Context, arg UpdateLessonTimeParams) error {
	_, err := q.db.Exec(ctx, updateLessonTime, arg.Time, arg.ID)
	return err
}

const updateMembership = `-- name: UpdateMembership :exec
INSERT INTO yoga.membership (user_id, starts, ends, type, lessons_avaliable)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (user_id) -- This is the column that might conflict
DO UPDATE SET
  type = EXCLUDED.type,
  starts = EXCLUDED.starts,
  ends = EXCLUDED.ends,
  lessons_avaliable = EXCLUDED.lessons_avaliable
`

type UpdateMembershipParams struct {
	UserID           int64
	Starts           time.Time
	Ends             time.Time
	Type             int
	LessonsAvaliable int
}

func (q *Queries) UpdateMembership(ctx context.Context, arg UpdateMembershipParams) error {
	_, err := q.db.Exec(ctx, updateMembership,
		arg.UserID,
		arg.Starts,
		arg.Ends,
		arg.Type,
		arg.LessonsAvaliable,
	)
	return err
}

const updateUserBio = `-- name: UpdateUserBio :exec
UPDATE yoga.user SET username=$1, name=$2 WHERE id=$3
`

type UpdateUserBioParams struct {
	Username pgtype.Text
	Name     string
	ID       int64
}

func (q *Queries) UpdateUserBio(ctx context.Context, arg UpdateUserBioParams) error {
	_, err := q.db.Exec(ctx, updateUserBio, arg.Username, arg.Name, arg.ID)
	return err
}

const upsertUser = `-- name: UpsertUser :exec
INSERT INTO yoga.user (id, username, name) VALUES ($1, $2, $3)
  ON CONFLICT(id) DO UPDATE SET
  username = EXCLUDED.username, name = EXCLUDED.name, is_blocked = false
`

type UpsertUserParams struct {
	ID       int64
	Username pgtype.Text
	Name     string
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.Exec(ctx, upsertUser, arg.ID, arg.Username, arg.Name)
	return err
}
